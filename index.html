<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Clustering Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root { --bg:#f6f8fa; --card:#ffffff; --accent:#0052cc; }
    html,body { height:100%; margin:0; font-family:Inter,Segoe UI,Roboto,Arial; }
    body { background:var(--bg); display:flex; justify-content:center; padding:18px; }
    .wrap { width:min(1200px,96vw); display:grid; grid-template-columns:1fr 340px; gap:14px; }
    .card { background:var(--card); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(16,24,40,0.06); }
    #plot { height:76vh; min-height:520px; border-radius:8px; }
    h1 { margin:0 0 6px 0; font-size:18px; color:#0f172a; }
    label { font-size:13px; color:#334155; }
    .row { display:flex; gap:8px; align-items:center; margin:8px 0; }
    input[type=number], select { padding:6px; border-radius:6px; border:1px solid #e6e9ef; width:86px; }
    button { background:var(--accent); color:white; padding:8px 10px; border-radius:8px; border:0; cursor:pointer; }
    button.ghost { background:#eef2ff; color:var(--accent); border:1px solid #dbeafe; }
    .toggle { display:flex; gap:6px; flex-direction:column; margin-top:8px; }
    .small { font-size:12px; color:#475569; }
    .footer { font-size:12px; color:#64748b; margin-top:6px; text-align:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Interactive 3D Clustering</h1>
      <div id="plot"></div>
    </div>

    <div class="card" style="display:flex;flex-direction:column">
      <div class="row" style="justify-content:space-between">
        <div>
          <label for="k">Clusters (K)</label><br>
          <input id="k" type="number" min="1" max="10" value="3">
        </div>
        <div>
          <label for="pts">Points / cluster</label><br>
          <input id="pts" type="number" min="10" max="1000" value="60">
        </div>
      </div>

      <div class="row">
        <button id="gen" class="ghost">Generate data</button>
        <button id="run">Run k-means</button>
      </div>

      <div class="row">
        <button id="step" class="ghost">Step</button>
        <button id="anim" class="ghost">Animate</button>
        <button id="stop" class="ghost">Stop</button>
      </div>

      <div style="margin-top:8px">
        <label>Plane visibility</label>
        <div class="toggle">
          <label><input type="checkbox" id="planeXY" checked> XY plane (Z=0)</label>
          <label><input type="checkbox" id="planeXZ" checked> XZ plane (Y=0)</label>
          <label><input type="checkbox" id="planeYZ" checked> YZ plane (X=0)</label>
        </div>
      </div>

      <div style="margin-top:12px">
        <label>Algorithm</label>
        <div class="small">K-means (Lloyd). Colors show current assignments; centroids are diamonds.</div>
      </div>

      <div class="footer">Rotate/zoom with mouse. Save as one HTML file and open with your browser.</div>
    </div>
  </div>

  <script>
    // Random normal
    function randn(mu=0, sigma=1) {
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return mu + sigma * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
    }
    const COLORS = ['#e11d48','#2563eb','#16a34a','#f97316','#7c3aed','#06b6d4','#db2777','#84cc16','#f59e0b','#0ea5e9'];

    // state
    let points = []; // {x,y,z,cluster}
    let centroids = [];
    let history = [];
    let animHandle = null;

    function generateData(K, per=60, spread=2.4) {
      points = [];
      const centers = [];
      const radius = Math.max(6, K*3);
      for (let i=0;i<K;i++){
        const ang = (i/K)*Math.PI*2;
        centers.push([radius*Math.cos(ang) + randn(0,1), radius*Math.sin(ang)+randn(0,1), randn(0,1)*2]);
      }
      centers.forEach(c=>{
        for (let j=0;j<per;j++){
          points.push({x: c[0]+randn(0,spread), y: c[1]+randn(0,spread), z: c[2]+randn(0,spread), cluster: null});
        }
      });
      points = points.sort(()=>Math.random()-0.5);
      centroids = []; history = [];
    }

    function kmeansStep(K) {
      if (centroids.length===0) {
        // init: K distinct random points
        const idxs = new Set();
        while (idxs.size < K) idxs.add(Math.floor(Math.random()*points.length));
        centroids = Array.from(idxs).map(i=>({x:points[i].x, y:points[i].y, z:points[i].z}));
      }
      // assign
      const assignments = new Array(points.length);
      for (let i=0;i<points.length;i++){
        let best=-1, bd=Infinity;
        for (let c=0;c<K;c++){
          const dx=points[i].x-centroids[c].x, dy=points[i].y-centroids[c].y, dz=points[i].z-centroids[c].z;
          const d=dx*dx+dy*dy+dz*dz;
          if (d<bd) { bd=d; best=c; }
        }
        assignments[i]=best;
      }
      // recompute
      const sums = Array.from({length:K},()=>({x:0,y:0,z:0,n:0}));
      for (let i=0;i<points.length;i++){
        const c=assignments[i]; sums[c].x+=points[i].x; sums[c].y+=points[i].y; sums[c].z+=points[i].z; sums[c].n+=1;
      }
      const newCentroids=[];
      for (let c=0;c<K;c++){
        if (sums[c].n===0) {
          const r=points[Math.floor(Math.random()*points.length)];
          newCentroids.push({x:r.x,y:r.y,z:r.z});
        } else newCentroids.push({x:sums[c].x/sums[c].n, y:sums[c].y/sums[c].n, z:sums[c].z/sums[c].n});
      }
      history.push({assignments, centroids: newCentroids});
      centroids = newCentroids;
      for (let i=0;i<points.length;i++) points[i].cluster = assignments[i];
      return assignments;
    }

    function runKmeans(K, maxIter=50) {
      history=[]; centroids=[];
      let prev=null;
      for (let it=0; it<maxIter; it++){
        const asg = kmeansStep(K);
        if (prev && asg.every((v,i)=>v===prev[i])) break;
        prev = asg.slice();
      }
    }

    function buildPlane(size=60) {
      const s=size;
      function rect(xs, ys, zs, color, name) {
        return { type:'mesh3d', x: xs, y: ys, z: zs, i:[0,0], j:[1,2], k:[2,3], opacity:0.12, color:color, name:name, hoverinfo:'none', showscale:false};
      }
      return [
        rect([-s,-s,s,s], [-s,s,s,-s], [0,0,0,0], '#94a3b8', 'XY plane (Z=0)'),
        rect([-s,-s,s,s], [0,0,0,0], [-s,s,s,-s], '#60a5fa', 'XZ plane (Y=0)'),
        rect([0,0,0,0], [-s,s,s,-s], [-s,-s,s,s], '#34d399', 'YZ plane (X=0)')
      ];
    }

    function repaint() {
      const K = Math.max(1, parseInt(document.getElementById('k').value||3));
      const grouped = Array.from({length:Math.max(K,1)},()=>({x:[],y:[],z:[]}));
      for (let i=0;i<points.length;i++){
        const c = (points[i].cluster===null || points[i].cluster===undefined) ? 0 : points[i].cluster % grouped.length;
        grouped[c].x.push(points[i].x); grouped[c].y.push(points[i].y); grouped[c].z.push(points[i].z);
      }
      const traces = [];
      for (let c=0;c<grouped.length;c++){
        traces.push({ x:grouped[c].x, y:grouped[c].y, z:grouped[c].z, mode:'markers', type:'scatter3d',
                      marker:{size:4, color:COLORS[c%COLORS.length], opacity:0.95}, name:'Cluster '+(c+1) });
      }
      if (centroids.length) {
        traces.push({ x:centroids.map(a=>a.x), y:centroids.map(a=>a.y), z:centroids.map(a=>a.z),
                      mode:'markers', type:'scatter3d', marker:{size:10,symbol:'diamond',color:'#0f172a'}, name:'Centroids' });
      }
      const planes = buildPlane(60);
      if (document.getElementById('planeYZ').checked) traces.unshift(planes[2]);
      if (document.getElementById('planeXZ').checked) traces.unshift(planes[1]);
      if (document.getElementById('planeXY').checked) traces.unshift(planes[0]);

      const layout = { margin:{l:0,r:0,b:0,t:26}, scene:{xaxis:{title:'X'},yaxis:{title:'Y'},zaxis:{title:'Z'}}, legend:{orientation:'h',y:1.02} };
      Plotly.react('plot', traces, layout, {responsive:true});
    }

    // UI wiring
    document.getElementById('gen').addEventListener('click', ()=>{
      stopAnim();
      const K = Math.max(1, parseInt(document.getElementById('k').value||3));
      const pts = Math.max(10, parseInt(document.getElementById('pts').value||60));
      generateData(K, pts);
      repaint();
    });

    document.getElementById('run').addEventListener('click', ()=>{
      stopAnim();
      const K = Math.max(1, parseInt(document.getElementById('k').value||3));
      runKmeans(K, 100);
      repaint();
    });

    document.getElementById('step').addEventListener('click', ()=>{
      stopAnim();
      const K = Math.max(1, parseInt(document.getElementById('k').value||3));
      kmeansStep(K);
      repaint();
    });

    document.getElementById('anim').addEventListener('click', ()=>{
      const K = Math.max(1, parseInt(document.getElementById('k').value||3));
      history = []; centroids = [];
      // collect steps
      for (let i=0;i<30;i++){
        kmeansStep(K);
        if (history.length>1) {
          const prev = history[history.length-2].assignments;
          const curr = history[history.length-1].assignments;
          if (curr.every((v,idx)=>v===prev[idx])) break;
        }
      }
      let step=0;
      stopAnim();
      animHandle = setInterval(()=>{
        if (step>=history.length) { stopAnim(); return; }
        const st = history[step];
        for (let i=0;i<points.length;i++) points[i].cluster = st.assignments[i];
        centroids = st.centroids.map(c=>({x:c.x,y:c.y,z:c.z}));
        repaint();
        step++;
      }, 450);
    });

    document.getElementById('stop').addEventListener('click', stopAnim);
    function stopAnim(){ if (animHandle){ clearInterval(animHandle); animHandle=null; } }

    ['planeXY','planeXZ','planeYZ'].forEach(id=>document.getElementById(id).addEventListener('change', repaint));

    // initial
    generateData(3,60);
    repaint();

    // helpful quick debug: show console instruction
    console.log('If the page is blank, open DevTools (F12) -> Console for errors, and confirm this file is loaded as .html.');
  </script>
</body>
</html>